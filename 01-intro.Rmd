# はじめに {#intro}

```{r, include=FALSE}
project_name = 'linear-economic-dynamics'
```

## 経済動学

「経済動学」（economic dynamics）では経済の状態を表す変数（経済指標）の時間を通じた変化，
あるいは変化の不在，を研究する。どのような問題を扱おうとしているのか整理しておこう。

学部レベルのミクロ経済学を履修した読者は次のような最適化問題には馴染みがあると思う。
$$
\begin{aligned}
  &\max_{c\in \mathbb{R}^N_+} u(c) \\
  &\text{subject to}\quad p \cdot c \le I  
\end{aligned}
$$
価格 $p = (p_1, \dots, p_N)$ と所得 $I$ のもとで，効用 $u(c)$ を最大にする消費量の組み合わせ 
$c = (c_1, \dots, c_N)$ を選べという問題である。この消費者モデルに対する標準的な仮定は，経済には$N$
種の異なる財があり，そのうちの第 $n$ 財, $n = 1, \dots, N$, には価格 $p_n$ が設定されている。
消費者はそれを $c_n$ 単位購入する。すべての財を購入するには，$p\cdot c = \sum_{n = 1}^N p_n x_n$ 
を支払う必要があるが，所得 $I$ を超える支出はできない。

各財を並べた順番 $n = 1, \dots, N$ は完全に任意である。
$c_n$ と $c_{n + 1}$ がそのように並んでいることには何の理由もない。したがって，例えば，
$c_1 < c_2 < c_3 < \cdots$ という**単調性（monotonicity）**が得られたとしても，
たまたまそのようになったという以上の解釈はできない。

モデルを変えずに，解釈を変更してみよう。経済には本質的には1つの財しかないとする。
例えば$c_1$ は2001年の消費，$c_2$ を2002年の消費という様に，
各 $c_n$ をある特定の時点における経済活動を表す変数と解釈する。このような解釈の変更は，
解くべきモデルを変えることなく結果の解釈を変える。すなわち，先程の単調性は，
年々消費が増えていくということを意味している。説明上，$N$ を有限としたが，$N = \infty$
のケースを考えることが多い。$N$ が有限のとき，
そのモデルは**有限ホライズン（finite horizon）**のモデルであるといい，
そうでないとき**無限ホライズン（infinite horizon）**であるという。

各変数が時間によってラベル付けされたモデルを解き，
その解が満たす経時的な性質を調べるのが経済動学の主要な課題である。
次のような命題に関心がある。

- 時間を通じて一定であるか，あるいは，十分時間が経てば収束状態に落ち着くか。
  それとも，発散や恒常的な振動経路が観測されるか。
- 収束経路は単調に増加（あるいは減少）するか，それとも振動的か。
- 恒常的な振動が観測さるケースでは，振動は規則的（周期的，
  periodic）かあるいは不規則的（カオス，chaos）か。
- 経済状態は過去の経路に依存して決まるか，それとも経路依存性はないか。
- 経済状態は一意的に定まるのか，あるいは経済主体の「気まぐれ」が経路を変えてしまうことがあるのか。
- etc.

モデルの解を特徴付ける方程式を**動学方程式（dynamic equation）**, あるいは**動的システム（dynamic system）**という。
経済学のモデルでは，消費者の効用最大化・企業の利潤最大化・種々の制約条件からなる最適化問題が満たす均衡条件として，
時点が隣り合う変数が満たす方程式を得られることが多い[^上のリストで挙げた「経路依存性」がないケースである。]。
$$
F(x_t, x_{t + 1}) = 0, \quad t = 1, 2, \dots
$$
ただし，$x_t$ は関心のある経済変数を並べたベクトルである。時間（time）を表すインデックスを
$t$ に変更した。経済政策などの外的な要因（ショック，shock）で経済環境が変化するケースを扱う場合には，
$$
  F(x_t, x_{t+1}, z_t) = 0
$$
といった動学方程式が得られることになる。これらのシステムは陰関数の解として変数が定まるという
意味で陰的システム（implicit system）である。

経済の経時的な変化を知るためには，$x_1, x_2, \dots$ という時系列が必要であるから，
理想的には逐次的な計算公式
$$
x_{n + 1} = G_t (x_t, z_t)
$$
が必要である。あるいは，$G$ の時間依存性がなければ，
$$
x_{n+1} = G(x_t, z_t)
$$
とできるかもしれない。上で例示したような動的システムは解くことができない。


## 対象とするモデル

この講義では，次のような動的システムを考察する。

\begin{equation}
  A\mathbb{E}_{t}x_{t+1}=Bx_{t}+Cz_{t} (\#eq:lre)
\end{equation}

$x_t$ はモデルを解いて決まる変数を並べたベクトル（内生変数，endogenous variable），
$z_t$ はモデルの外で決まる変数（外生変数，exogenous variable）。$A$, $B$, $C$ は適切なサイズの行列である。
$\mathbb E_t$ は条件付き期待値である。

行列積と足し算だけからなる上記のようなシステムを線形システム（linear system）という。上の線形方程式を
\begin{equation} 
  Bx_{t} = A\mathbb{E}_{t}x_{t+1} - Cz_{t} (\#eq:lre2)
\end{equation}
と書き換えると，**今期の経済変数は将来に対する期待によって定まっている**と読むことができる。
式\@ref(eq:lre) や 式\@ref(eq:lre2) のようなシステムを **線形合理的期待モデル (linear rational expectations model)** という。

本書ではモデルの導出に深く踏み込まないが，価格や消費といった変数は将来に対する予想を反映して (forward-looking) 決まるということだけ意識しておけば十分だろう。
予想を反映して価格が決まるという関係は次のような例を通して理解できる。

```{block2, type="example"}
企業の株価はその企業が将来的に生み出す価値を利子率 (あるいは割引率) を考慮して割引いた値と一致するように決まる，というのが経済理論の基本公式である。
なお， 「割引」(discount) というのは収益を手にするまでに待たなければいけない時間分だけ減価調整することである。

このような関係が成立する理由は比較的容易に理解できる。
ある企業の期待収益の割引現在価値がその企業の株価総額よりも一時的に高いとしよう。
当該株式を購入すれば 長い時間を通じて購入価格よりも高い収益を得ることができるのだから，
そのような株式には買い手が集まり，市場価格は上昇する。逆に，
期待収益が株価総額を一時的に下回っているとしよう。
株主は株式を手放すインセンティブを持つが，そのような市場価格では買い手はつかない。
売値を下げてでも売りたいと考える株主がいなくなるまで株価は下落するだろう。
予想した価値と市場価格の不一致が解消された結果として達成されるのが先の価格公式というわけである。

利鞘を稼ぐチャンス（裁定機会，arbitrage opportunity）が存在すれば，
市場を通じて価格が速やかに調整され，その結果として裁定機会は失われる。
経済理論は裁定機会が消滅した後の経済環境（均衡）に焦点を当てて分析を行うことが多いが，
それは上のような思想に基づいている。
```

通常, 経済モデルは非線形システム（線形でないシステムをすべて非線形システムという）
によって記述されることが多いのだが, 非確率的な平衡点 $x^* = x_t = x_{t+1}$, $z_t = 0$
（$t > 0$）の周りに分析を限定すれば，線形システムによってよく近似されることが知られている[^Hartman]。

[^Hartman]: Hartman-Grobman の定理。 この定理が成り立つためには平衡点が双曲型であるという条件が必要である。
双曲的でないシステムは非線形モデルの近似としては意味をなさないが，
線形モデルとして扱う分には特段の区別をする必要はない。

線形システムの分析は係数行列 (上記の $A$，$B$，$C$) の分析に落とし込むことができるため，
理論的にも数値的にも大変扱いやすい。したがって，
これから我々が学ぶ分析手法は**平衡状態にある経済に対して小さなショックが加わったときに経済変数がどのような経時的変化を示すかを分析するための第一歩**である。
実際には線形近似のみから数量的なインプリケーションを導くことは困難であるから，
有用な分析を行うためには高次の近似手法を学ぶ必要がある。しかし，
線形理論を理解することなく非線形理論を理解することはできない。一歩一歩着実に進んでいこう。

### 決定論モデル

実は確率的な要因がなくなったとしても分析の基本的な方針は変わらない。すなわち，
非確率的 (決定論的) なシステム

\begin{equation}
  Ax_{t+1} = Bx_t + Cz_t (\#eq:lsys)
\end{equation}

を分析する手法を確立すれば，\@ref(eq:lre) の分析・シミュレーションができる。
まずは \@ref(eq:lsys) の分析について述べたのち，
確率的な要因を導入するというステップで理論分析を進める。

さらに，非決定論的な分析を数段階に分けて解説する。

1. $A$ が正則のケース
    - 解析的手法
    - 数値的手法

2. $A$ が非正則のケース
    - 解析的手法
    - 数値的手法

$A$ が正則のケースでは \@ref(eq:lsys) は

\begin{equation}
  x_{t+1} = A^{-1}Bx_t + A^{-1}Cz_t (\#eq:lsys)
\end{equation}

と同値であるから（$A^{-1}$ は $A$ の逆行列），
標準的な線形システム (状態空間方程式) と形式的には同じものである。


続いて，$A$ が非正則のケースを扱う。上記の \@ref(eq:lsys) は，
制御理論の分野でデスクリプタシステム（descriptor system），
あるいは陰的システム（implicit system）として知られている対象である。  この分野で研究を進めようという人は，
同じ概念が異なる分野で異なる名前で利用されていることを知っておく方がよいだろう。

ちなみに，デスクリプタシステムは「非因果的」（non-causal）
なシステムを表現するために利用される。すなわち，未来の情報が現在に影響をおよぼすようなシステムである。
どこかで聞いたことのある話ではないだろうか？
経済学における "forward-looking" は制御理論では非因果性と呼ばれている。 

### 制御理論との違い

ただし経済学と制御理論の扱う対象が完全に同じだという訳ではない。経済モデルは，
$A$が正則であったとしても forward-looking（非因果的）な現象を表すように作られている。

力学系理論や制御理論で式\@ref(eq:lsys)のようなシステムを扱うときには，
通常 $x$ と同じ数だけの初期条件 (initial codition) を与える。
そのようなケースでは初期条件から出発してシステムの解を逐次的に求めることができるから，
解を求める上で特段の難しさはない。一方，経済学における forward-looking の表現は，
システム方程式\@ref(eq:lsys)とは独立している。
すなわち，変数（ベクトル） $x$ の一部の要素に初期条件が与えられて，
残りの要素には初期条件が与えられないという形で forward-looking を扱う。
初期条件を持つ成分を**先決成分 (predetermined component)** とか**先決変数 (predetermined variable)**と呼ぶ。
初期条件を持たない成分を**非先決成分 (non-predetermined component)** とか**非先決変数 (non-predetermined variable)**
と呼ぶ^[確率的な要因を含むモデルではやや異なる定義をするが，
基本的には同じことである。]。

例えば, 株式保有量を$a$，株価を$p$，株価に対する外的な影響を$u$として，
ベクトル $(a, p)$ が次の動学方程式を満たすというモデルを作ったとしよう。

$$
\begin{bmatrix}
  a_{t+1} \\
  p_{t+1}
\end{bmatrix}
=
B
\begin{bmatrix}
  a_{t} \\
  p_{t}
\end{bmatrix}
+
\begin{bmatrix}
  0 \\
  u_{t}
\end{bmatrix}
$$

このとき $a_0$ は初期値として与えられているが，$p_0$ は $a_0$ および $u$
に対する予想に基いて決まるというのが典型的なマクロ経済学の問題である. 

### 安定性と決定性

さて，一部の変数に初期条件が与えられていない問題をどのように解けばよいだろうか。
もちろん，$a_1, a_2, \dots$ や $p_0, p_1, \dots$
に対して何の制約も置かなければこのような問題を解くことはできない。

@BlanchardKahn1980 が提案した条件は次のようなものである。
経済主体は幾何級数よりも早いスピードで発散するような予想に基いて行動することはない。
すなわち，幾何級数より早く発散するような初期値を除いた結果，初期値を1点に定めることができれば，
その点は一意の均衡である。しかし，動学方程式を満たしつつ，
安定性（非幾何的発散）を満足するような経路は一般には無数に存在する。一意的であるようなケースを
**決定的 (deterinate)** と呼び，決定的でないケースを **不決定的 (indeterminate)** と呼ぶ。



### 合理的期待モデル

続いてシステム \@ref(eq:lre) の分析を行う. ショック項 $z$ を確率過程となるが,  決定論の分析を理解していれば, 条件付き期待値の性質を少し覚えるだけで理解できるようになる. 決定論モデルと同じ安定性の概念を利用して決定性を特徴づけることができるので, 実は決定論システムと本質的な違いはない. 

本書では, やや発展的な話題を紹介する.

### マルコフスイッチングモデル

次に, 係数行列がマルコフ連鎖に従って変化するモデルに拡張する. このような拡張をすると, 伝統的な合理的期待モデルが利用してきた安定性の概念を利用することができなくなる. **二乗平均安定性 (Mean Square Stability)**という安定性概念を導入し, 決定性を特徴付ける.

## プログラミング環境

### RStudio

前述のような線形モデルは (広く普及している C, Fortran のルーチンのおかげで) 大抵のプログラミング言語で解くことができる. 本書で R を使用するのは, 想定する読者層がもっとも接近しやすい言語であろうと考えたからである. 計量経済学の学習は Stata を使い, マクロ経済学では Matlab, 数理経済学の授業では Python というようなことにもなりがちだが, プログラミングの初級者は1つの言語に深く習熟するようにした方がよい.  将来的に他の言語に移るとしても, 広く浅く学んだ人よりも深く狭く学んだ人の方が, 速く学ぶ.


R は計量経済学のツールとしてもとても優秀で, しかも多くのユーザーコミュニティがある. データ収集, 図示, モデリング, ドキュメント作成のすべての工程をRとRStudio で実行することができる. RStudio に触れる機会を増やすために, すべてのレポートを RStudio で作成するように気持ちを切り替えてみよう. RMarkdown という書式で書き, それをコンパイルする. knitr や pandoc がスムーズに仕事をこなしてくれる. PDF に変換するには texlive をインストールする. サイズは大きいが簡単だ. 数式を入力するには LaTeX の構文を覚える必要があるが, 大学院にいる以上いずれ必要になる技術だから, 今やっておいて損はない. RMarkdown は LaTeX そのものと比べると概ね自然に書くことができるし, 何よりも R のコードや計算結果, グラフを文章内に埋め込むのが非常に簡単だ. ところで, 本書も RStudio で書いている. いくつかの RMarkdown ファイル, 設定ファイルを bookdown というパッケージがうまく処理してくれる.  

R に十分習熟し, プロファイリングの努力も虚しく計算速度に限界を感じることがあるかもしれない. そうなった C++ を少し学べばよい. 重い処理だけを扱う C++ のコードを用意し, RCpp パケージを使って呼び出すことができる. そのような願望が現れるころには計算機の仕組みをある程度理解しているだろうから, C++ も速く学べると思う. 

本書のコードに関する解説は, 読者が RStudio で作業をしているものと想定している. Rプログラミングの経験が浅い読者は, 筆者と同様の環境を構築しておくほうが混乱がないだろう. 本節の残りの部分で RStudio  の使い方に関する簡単な説明と, 環境構築を行う.  

### 準備

R 本体も RStudio もバイナリファイルをダウンロードして簡単にインストールすることができるので, インストールに関する詳細は省略する. 

このコースの学習用に RStudio プロジェクトファイルを用意しておこう. RStudio を起動し, メニューから「File > New Project...」をクリックして新しいプロジェクトを作成する. 作成方法に関していくつかの選択肢を提示されるので, 特に問題がなければ「New Directory > Empty Project」を選ぶ. 必要な入力項目を入力する. 例えば, プロジェクト名を`r project_name` としておこう. 指定したディレクトリの配下に, `r project_name` という名前の新しいディレクトリ (フォルダ) , さらにその中に `r paste0(project_name, '.Rproj')` というファイルが作成される. 

作業再開時には, `r paste0(project_name, '.Rproj')` をダブルクリックして, RStudio が開く. 先程作ったディレクトリが作業ディレクトリになる. プロジェクト作成直後はすでに作業ディレクトリを移っているのでそのまま進めて構わない.

```{block2, type="exercise"}
次の用語を説明する. 説明できない場合は検索して調べる. 

- ディレクトリ, フォルダ, directory, folder
- 作業ディレクトリ, working directory / current directory
- 相対パス, relative path
- 絶対パス, absolute path
- コンソール, console
- スクリプトファイル, script file

```

コマンドの実行はコンソールに入力＋Enter 押下でもよいし, コマンドをスクリプトファイルに書いて実行してもよい.

#### コンソール {-}

Console と書かれたエリアを探してほしい. 設定をいじっていなければ,[^locale]

[^locale]: OSの言語に合わせて R のメッセージの言語が異なるかもしれない.            筆者は英語で利用することを強く推奨する. 未知のエラーに遭遇したときに, 英語の方が情報が得られやすい. ロカールの変更方法は各自調べること.

```
R version 3.3.2 (2016-10-31) -- "Sincere Pumpkin Patch"
Copyright (C) 2016 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.4.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

>
```

という表示が見えるはずだ. 最後の記号 「>」は「プロンプト」と呼ばれる. ここにコマンドを入力せよという意味である. 

本書では, コンソールに入力して実行して結果を確認するという文脈であってもプロンプトを表示しない. 各自入力して実行してほしいコマンドは次のようなグレーのボックスで表示する. 


```{r}
10 * 3
```

`[1] 30` は実行結果であり, `10 * 3` の結果が `r 10 * 3` であることを意味している. 先頭についている `##` は特に意味はない. `[1]` は今のところ無視してもよい.  **コマンドの直後に配置された白背景のボックスに直前のコマンドの実行結果を掲載する**.


プロンプトを省略することで, 複数行にわたるコマンドであってもコピー＆ペーストで実行できるという利点がある. 次のコードをまるごとコピーして, コンソールにペーストし, Enter を押下すればPlotsペインに結果が出力されるはずだ.

```{r, fig.cap="'01_cobbdouglas_plot.R' の実行結果"}
# 01_cobbdouglas_plot.R

A = 1.2
alpha = 0.3
cobbdouglas = function(k) {
  return(A * k ^ alpha)
}

k = seq(0, 10, length.out=200)
y = cobbdouglas(k)
plot(k, y, type='l')
```

`#` に続く内容は, プログラマが読むためだけのコメントである. 本書の約束事として, コードチャンクの1行目のコメントには, スクリプトとして保存する場合のファイル名や, 本文中で参照するための短いキャプションを書くことにする.


#### スクリプトファイル {-}

スクリプトファイルを保存するディレクトリを作っておこう. Files ペインを探して内容を見ると `r paste0(project_name, '.Rproj')` ファイルを見つけられる思う. そこがプロジェクトディレクトリの最上位階層 (ルートディレクトリ) である. もし当該ファイルが見当たらなければ, ディレクトリ階層を移動して探してほしい.  元いた場所から離れることができたのだから戻ることもできるはずだ. 帰れなくなったら RStudio を終了して, 再び .Rproj をダブルクリックして起動しなおせばよい. 

プロジェクトの .Rpoj ファイルが見つかったら「New Folder」というボタンを押して, 「R」という名前の新しいディレクトリを作る.

**スクリプト (script)**とは1つ以上のコマンドをまとめたファイルのことである. R はスクリプトファイルを読んで, 上から順番に実行することができる. コンソール上での作業は複数行に渡るコードを入力するには不向きなので, 別途ファイルに保存しておくことで生

RStudio で新しいスクリプトファイルを作るにはいくつかの方法がある.

- RStudio 左上にあるるボタン (白い四角の上に足し算記号のマーク) 
  から「R Script」を選びクリックする. 
- メニューから「File > New File > R Script」と進む.
- **キーボードショートカット Ctrl+Shift+N / Cmd+Shift+N を押下する**

最後のキーボードショートカットを覚えるのが一番よいだろう. 
Cmd+Shit+N を押下すると, Untitled1 という名前でソースペインが開く. ここに先程の `01_cobbdouglas_plot.R` のコードをコピー＆ペーストしてみよう. Ctrl+S / Cmd+S によって保存しようとすると, 保存場所と名前を決めるように促されるので, 先程作成しておいた R というフォルダに, `01_cobbdouglas_plot.R` という名前で配置する. プロジェクトディレクトリは次のような構成になっているはずだ.[^hidden]

[^hidden]: 実際には .Rproj.user という隠しディレクトリがある. 

```
linear-economic-dynamics
├── R
│   └── 01_cobbdouglas_plot.R
└── linear-economic-dynamics.Rproj
```

作業ディレクトリ (linear-economic-dynamics) にある, R というサブディレクトリの中にある `01_cobbdouglas_plot.R` というスクリプトファイルを実行するには以下のようにする.

```{r, eval=FALSE}
source('R/01_cobbdouglas_plot.R')
```

作業ディレクトリを起点としたファイルの位置を**相対パス (relative path)**という. スクリプト内にファイルパスを書く場合は, やむを得ない事情で移動できない場合を除いて必ず相対パスで指定するようにする.


さきほどのスクリプトファイルはもっと下位のサブディレクトリに配置することもできる. 例えば, 章ごと節ごとにディレクトリを作って

```
source('R/part1/chapter03/section04/subsection01/01.R')
```

ということも可能ではある. しかし, 階層が深くなりすぎると管理が難しくなるので, できるだけフラットにしておくようにしよう. この本では, 

```
R/chapternumber_descriptive_name.R
```

という形式のファイル名をつけ, すべて R ディレクトリの直下に配置する. 

### パッケージ

#### tidyverse {-}

本書では `tidyverse` パッケージを利用する. `tidyverse` はRのデータフレーム操作を円滑にするためのパッケージ群である. 必要なもの以上に関数を読み込むことを望まない場合には, `ggplot2`, `dplyr`, `tidyr` を必要に応じて読み込むとよい.

試しにプロンプトに

```{r}
library(tidyverse)
```

と打ち込んでみよう. エラーが出る場合には次のコマンドでインストールしてから, 再度実行する. 

```{r, eval=FALSE}
install.packages("tidyverse")
```
```
Loading tidyverse: ggplot2
Loading tidyverse: tibble
Loading tidyverse: tidyr
Loading tidyverse: readr
Loading tidyverse: purrr
Loading tidyverse: dplyr
Conflicts with tidy packages ---------------------------------------------------------
filter(): dplyr, stats
lag():    dplyr, stats
```
といったメッセージが出ると思う. `tidyverse` はパッケージ群なので, 幾つかの個別のパッケージを読み込むのが仕事である. Conflicts が出て心配になるかもしれないが, 特に問題はない. `filter()`, `lag()` という関数がデフォルトで読み込まれているにもかかわらず, 同じ名前を持つ `dplyr` を読み込んだことで`filter()`, `lag()` という関数の実体が変更されてしまった. もし, デフォルトの `filter()` を使いたければ, `stats::filter()` と呼び出せばよい. `stats::` や `dplyr::` といったプレフィックスは, 関数やオブジェクトがどのパッケージで定義されたものかを明示したいときに使う. 

本書では, `base::data.frame()` の代わりに `tibble::tibble()` を利用する. `tibble` パッケージは `tidyverse` に含まれている. 違いを簡単に見ておこう.

```{r}
x = c(1, 2, 3)
y = c('a', 'b', 'c')
z = c(TRUE, TRUE, FALSE)

(df = data.frame(x = x, y = y, z = z))
```

```{r}
(tbl = tibble(x = x, y = y, z = z))
```

base のデータフレームと比べて, tibble は次の点で扱いやすい.

- データのサイズを表示してくれる
- コラムの型情報を表示する (`<dbl>`, `<chr>`, `<lgl>`)
- 文字列をファクター型にしない

ファクター型は, 文字列を内部的に整数値として保存している. これを文字列と思って扱うと問題が起こる. 例えば,

```{r}
"a" < "b"
```

と同じ振る舞いを期待して, 次のような評価をすると問題が起こる:

```{r}
df$y[1] < df$y[2]
```


#### QZ {-}

同様に `QZ` パッケージもインストールしておこう. 後々利用することになる.

```{r, eval=FALSE}
install.packages("qz")
```

#### devtools {-}

パッケージ開発環境. `devtools::github_install()` を使って, github レポジトリからパッケージをインストールできるようになる.  

**Step 1**:

コンパイラをインストールする.

- **Windows**: [Rtools (https://cran.r-project.org/bin/windows/Rtools/)](https://cran.r-project.org/bin/windows/Rtools/) をインストール
- **Mac**: Xcode をインストール

**Step 2**:

CRAN からインストール.

```{r, eval=FALSE}
install.packages("devtools")
```



